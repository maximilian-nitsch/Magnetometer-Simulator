#include "mag_simulator.h"

#include <iomanip>
#include <iostream>

namespace mag_simulator {

/**
 * @brief Constructor of the MagSimulator class.
 *
 * This constructor initializes the MAG simulator with the given parameters.
 *
 * @param[in] localMagFieldVector The local magnetic field vector in Tesla (T).
 *                                It should be a 3-dimensional vector
 * representing the magnetic field components along the N, E, and D axes.
 * @param[in] magSimParams        The MAG simulation parameters specifying
 * various settings and configurations for the simulator.
 * @param[in] modelEnableSettings The model enable settings determining which
 * simulation models are enabled for computation.
 * @param[in] dt                  The sampling time in seconds (s). It specifies
 * the time interval at which the magnetometer samples are generated.
 * @param[in] seed                The seed for the random number generator used
 * internally by the simulator to generate stochastic processes.
 *
 * @return An instance of the MagSimulator class initialized with the provided
 * parameters. The returned instance is ready for simulation and further
 * configuration.
 */
MagSimulator::MagSimulator(Eigen::Vector3d localMagFieldVector,
                           MagSimParams magSimParams,
                           ModelEnableSettings modelEnableSettings, double dt,
                           unsigned int seed)
    : localMagFieldVector_(localMagFieldVector),
      magSimParams_(magSimParams),
      pStochasticErrors_(std::make_shared<StochasticErrors>()),
      modelEnableSettings_(modelEnableSettings),
      dt_(dt),
      randomNumberGenerator_(seed),
      seed_(seed),
      normalDistribution_(0, 1) {

  // Initialize MAG stochastic error structs
  pStochasticErrors_->z_N = Eigen::Vector3d::Zero();
  pStochasticErrors_->z_B = Eigen::Vector3d::Zero();
  pStochasticErrors_->z_K = Eigen::Vector3d::Zero();
}

/**
 * @brief Destructor of the MagSimulator class.
 *
 * This destructor is responsible for cleaning up the resources used by the MAG
 * simulator.
 *
 * @return None
 */
MagSimulator::~MagSimulator() {}

/**
 * @brief Generate a magnetometer measurement.
 *
 * This function generates a magnetometer measurement based on the given true
 * attitude quaternion. The measurement is generated by applying the ideal
 * measurement model and then adding various error models such as hard iron
 * bias, soft iron distortion, stochastic errors, saturation, and quantization.
 *
 * @param[in] q_b_n_true The true attitude quaternion of the body frame with
 * respect to the navigation frame.
 *
 * @return The generated magnetometer measurement in the sensor frame.
 */
Eigen::Vector3d MagSimulator::generateMagnetometerMeasurement(
    const Eigen::Quaterniond q_b_n_true) {
  // Check if local magnetic field vector is not zero/has been set
  if (localMagFieldVector_.isZero()) {
    std::cerr << "MAG simulator: Local magnetic field vector is zero!"
              << std::endl;
    return Eigen::Vector3d::Zero();
  }

  // Check if local magnetic field vector norm is within min/max range
  if (localMagFieldVector_.norm() < 2.0e-05 &&
      localMagFieldVector_.norm() > 7.0e-05) {
    std::cerr << "MAG simulator: intensity of local magnetic field vector is "
                 "not in 20-70 ÂµT!"
              << std::endl
              << "The intensity of the local magnetic field vector is "
              << localMagFieldVector_.norm() << " T." << std::endl
              << "Please check the local magnetic field vector!" << std::endl;

    return Eigen::Vector3d::Zero();
  }

  // Calculate true magnetic field vector in sensor frame
  Eigen::Vector3d m_s_meas = calcIdealMeasurement(q_b_n_true);

  //   // Apply magnetic anomalies (TODO: implement)
  //   if (modelEnableSettings_.enableMagneticAnomalies) {
  //     m_s_meas = m_s_meas + m_s_AM;
  //   }

  // Apply soft iron distortion
  if (modelEnableSettings_.enableSoftIronDistortion) {
    m_s_meas = calcSoftIronDistortionModel(m_s_meas);
  }

  // Apply hard iron bias
  if (modelEnableSettings_.enableHardIronBias) {
    m_s_meas = calcHardIronBiasModel(m_s_meas);
  }

  // Apply stochastic errors (colored noise)
  if (modelEnableSettings_.enableStochasticError) {
    m_s_meas = calcStochasticErrorModel(m_s_meas);
  }

  // Apply saturation
  if (modelEnableSettings_.enableSaturation) {
    m_s_meas = calcSaturationModel(m_s_meas);
  }

  // Apply quantization
  if (modelEnableSettings_.enableQuantization) {
    m_s_meas = calcQuantizationModel(m_s_meas);
  }

  return m_s_meas;
}

/**
 * @brief Reset the MAG simulator.
 *
 * This function resets the MAG simulator by setting the stochastic errors to
 * zero.
 *
 * @return None
 */
void MagSimulator::resetSimulator() {
  // Reset MAG stochastic errors
  pStochasticErrors_->z_N = Eigen::Vector3d::Zero();
  pStochasticErrors_->z_B = Eigen::Vector3d::Zero();
  pStochasticErrors_->z_K = Eigen::Vector3d::Zero();
}

/**
 * @brief Get the local magnetic field vector.
 *
 * This function returns the local magnetic field vector used by the MAG
 * simulator.
 *
 * @return The local magnetic field vector in Tesla (T).
 */
Eigen::Vector3d MagSimulator::getLocalMagFieldVector() const {
  return localMagFieldVector_;
}

/**
 * @brief Get the MAG simulation parameters.
 *
 * This function returns the MAG simulation parameters used by the MAG
 * simulator.
 *
 * @return The MAG simulation parameters.
 */
MagSimParams MagSimulator::getMagSimParams() const {
  return magSimParams_;
}

/**
 * @brief Get the seed of the random number generator.
 *
 * This function returns the seed of the random number generator used by the MAG
 * simulator.
 *
 * @return The seed of the random number generator.
 */
unsigned int MagSimulator::getSimulatorSeed() const {
  return seed_;
}

/**
 * @brief Get the MAG sample time.
 *
 * This function returns the sample time used by the MAG simulator.
 *
 * @return The sample time in seconds (s).
 */
double MagSimulator::getMagSampleTime() const {
  return dt_;
}

/**
 * @brief Get the model enable settings.
 *
 * This function returns the model enable settings used by the MAG simulator.
 *
 * @return The model enable settings.
 */
ModelEnableSettings MagSimulator::getModelEnableSettings() const {
  return modelEnableSettings_;
}

/**
 * @brief Get the hard iron bias.
 *
 * This function returns the hard iron bias used by the MAG simulator.
 *
 * @return The hard iron bias in Tesla (T).
 */
Eigen::Vector3d MagSimulator::getHardIronBias() const {
  return magSimParams_.hardIronBias;
}

/**
 * @brief Get the soft iron distortion.
 *
 * This function returns the soft iron distortion used by the MAG simulator.
 *
 * @return The soft iron distortion matrix.
 */
Eigen::Matrix<double, 3, 3> MagSimulator::getSoftIronDistortion() const {
  return magSimParams_.softIronDistortion;
}

/**
 * @brief Get the stochastic errors.
 *
 * This function returns the stochastic errors used by the MAG simulator.
 *
 * @return The stochastic errors.
 */
StochasticErrors MagSimulator::getStochasticErrors() const {
  return *pStochasticErrors_;
}

/**
 * @brief Get the flag indicating if fixed random numbers are used in stochastic
 * error model.
 *
 * This function returns the flag indicating if fixed random numbers are used in
 * the stochastic error model.
 *
 * @return The flag indicating if fixed random numbers are used.
 */
bool MagSimulator::getUseFixedRandomNumbersFlag() const {
  return useFixedRandomNumbers_;
}

/**
 * @brief Set the local magnetic field vector.
 *
 * This function sets the local magnetic field vector used by the MAG simulator.
 *
 * @param[in] localMagFieldVector The local magnetic field vector in Tesla (T).
 *
 * @return None
 */
void MagSimulator::setLocalMagFieldVector(
    const Eigen::Vector3d& localMagFieldVector) {
  localMagFieldVector_ = localMagFieldVector;
}

/**
 * @brief Set the MAG simulation parameters.
 *
 * This function sets the MAG simulation parameters used by the MAG simulator.
 *
 * @param[in] magSimParams The MAG simulation parameters.
 *
 * @return None
 */
void MagSimulator::setMagSimParams(const MagSimParams& magSimParams) {
  magSimParams_ = magSimParams;
}

/**
 * @brief Set the seed of the random number generator.
 *
 * This function sets the seed of the random number generator used by the MAG
 * simulator.
 *
 * @param[in] seed The seed of the random number generator.
 *
 * @return None
 */
void MagSimulator::setSimulatorSeed(const unsigned int seed) {
  randomNumberGenerator_.seed(seed);
  seed_ = seed;
}

/**
 * @brief Set the MAG sample time.
 *
 * This function sets the sample time used by the MAG simulator.
 *
 * @param[in] dt The sample time in seconds (s).
 *
 * @return None
 */
void MagSimulator::setMagSampleTime(const double dt) {
  dt_ = dt;
}

/**
 * @brief Set the model enable settings.
 *
 * This function sets the model enable settings used by the MAG simulator.
 *
 * @param[in] modelEnableSettings The model enable settings.
 *
 * @return None
 */
void MagSimulator::setModelEnableSettings(
    const ModelEnableSettings& modelEnableSettings) {
  modelEnableSettings_ = modelEnableSettings;
}

/**
 * @brief Set the flag indicating if hard iron bias model is enabled.
 *
 * This function sets the flag indicating if the hard iron bias model is
 * enabled.
 *
 * @param[in] enable The flag indicating if the hard iron bias model is enabled.
 *
 * @return None
 */
void MagSimulator::setEnableHardIronBias(const bool enable) {
  modelEnableSettings_.enableHardIronBias = enable;
}

/**
 * @brief Set the flag indicating if soft iron distortion model is enabled.
 *
 * This function sets the flag indicating if the soft iron distortion model is
 * enabled.
 *
 * @param[in] enable The flag indicating if the soft iron distortion model is
 * enabled.
 *
 * @return None
 */
void MagSimulator::setEnableSoftIronDistortion(const bool enable) {
  modelEnableSettings_.enableSoftIronDistortion = enable;
}

/**
 * @brief Set the flag indicating if stochastic error model is enabled.
 *
 * This function sets the flag indicating if the stochastic error model is
 * enabled.
 *
 * @param[in] enable The flag indicating if the stochastic error model is
 * enabled.
 *
 * @return None
 */
void MagSimulator::setEnableStochasticError(const bool enable) {
  modelEnableSettings_.enableStochasticError = enable;
}

/**
 * @brief Set the flag indicating if saturation model is enabled.
 *
 * This function sets the flag indicating if the saturation model is enabled.
 *
 * @param[in] enable The flag indicating if the saturation model is enabled.
 *
 * @return None
 */
void MagSimulator::setEnableSaturation(const bool enable) {
  modelEnableSettings_.enableSaturation = enable;
}

/**
 * @brief Set the flag indicating if quantization model is enabled.
 *
 * This function sets the flag indicating if the quantization model is enabled.
 *
 * @param[in] enable The flag indicating if the quantization model is enabled.
 *
 * @return None
 */
void MagSimulator::setEnableQuantization(const bool enable) {
  modelEnableSettings_.enableQuantization = enable;
}

/**
 * @brief Set the flag indicating if fixed random numbers are used in stochastic
 * error model.
 *
 * This function sets the flag indicating if fixed random numbers are used in
 * the stochastic error model.
 *
 * @param[in] enable The flag indicating if fixed random numbers are used.
 *
 * @return None
 */
void MagSimulator::setUseFixedRandomNumbersFlag(const bool enable) {
  useFixedRandomNumbers_ = enable;
}

/**
 * @brief Print the MAG simulator parameters.
 *
 * This function prints the MAG simulator parameters to the standard output.
 *
 * @return A stringstream containing the MAG simulator parameters.
 */
std::stringstream MagSimulator::printMagSimulatorParameters() {
  // Create stringstream to store the output
  std::stringstream ss;

  ss << "***************************************************************"
        "**********************************************************************"
        "*"
     << "\n";
  ss << std::left << std::setw(50) << "Starting MAG Simulator"
     << "\n";
  ss << "***************************************************************"
        "**********************************************************************"
        "*"
     << "\n";

  // Simulation parameters
  ss << std::left << "Simulation parameters:\n";
  ss << std::left << std::setw(50) << "N:" << magSimParams_.N.transpose() * 1e6
     << " ÂµT^(1/2)\n";
  ss << std::left << std::setw(50) << "B:" << magSimParams_.B.transpose() * 1e6
     << " ÂµT\n";
  ss << std::left << std::setw(50) << "K:" << magSimParams_.K.transpose() * 1e6
     << " ÂµT^(3/2)\n";
  ss << std::left << std::setw(50)
     << "corrTime:" << magSimParams_.corrTime.transpose() << " s\n";
  ss << std::left << std::setw(50)
     << "hardIronBias:" << magSimParams_.hardIronBias.transpose() * 1e6
     << " ÂµT\n";
  ss << std::left << std::setw(50)
     << "softIronDistortion:" << magSimParams_.softIronDistortion(0) << " "
     << magSimParams_.softIronDistortion(1) << " "
     << magSimParams_.softIronDistortion(2) << " "
     << magSimParams_.softIronDistortion(3) << " "
     << magSimParams_.softIronDistortion(4) << " "
     << magSimParams_.softIronDistortion(5) << " "
     << magSimParams_.softIronDistortion(6) << " "
     << magSimParams_.softIronDistortion(7) << " "
     << magSimParams_.softIronDistortion(8) << "\n";
  ss << std::left << std::setw(50)
     << "measRange:" << magSimParams_.measRange.transpose() * 1e6 << " ÂµT\n";
  ss << std::left << std::setw(50)
     << "resolution:" << magSimParams_.resolution.transpose() * 1e6
     << " ÂµT/LSB\n";
  ss << std::left << std::setw(50) << "sensorRotation (RPY angle):"
     << magSimParams_.sensorRotation.eulerAngles(2, 1, 0).transpose() * 180 /
            M_PI
     << " deg\n";
  ss << "***************************************************************"
        "**********************************************************************"
        "*"
     << "\n";

  // Model enable settings
  ss << std::left << "Model enable settings:\n";
  ss << std::left << std::setw(50)
     << "Hard iron bias:" << modelEnableSettings_.enableHardIronBias << "\n";
  ss << std::left << std::setw(50)
     << "Soft iron distortion:" << modelEnableSettings_.enableSoftIronDistortion
     << "\n";
  ss << std::left << std::setw(50)
     << "Stochastic error:" << modelEnableSettings_.enableStochasticError
     << "\n";
  ss << std::left << std::setw(50)
     << "Saturation:" << modelEnableSettings_.enableSaturation << "\n";
  ss << std::left << std::setw(50)
     << "Quantization:" << modelEnableSettings_.enableQuantization << "\n";
  ss << "***************************************************************"
        "**********************************************************************"
        "*"
     << "\n";

  // Environmental parameters
  ss << std::left << "Environmental parameters:\n";
  ss << std::left << std::setw(50)
     << "Local magnetic field vector:" << localMagFieldVector_.transpose() * 1e6
     << " ÂµT\n";

  ss << "***************************************************************"
        "**********************************************************************"
        "*"
     << "\n";

  // Sampling time and frequeqncy
  ss << std::left << std::setw(50) << "Sampling time:" << std::fixed
     << std::setprecision(6) << dt_ << " s\n";
  ss << std::left << std::setw(50) << "Sampling frequency:" << std::fixed
     << std::setprecision(6) << 1.0 / dt_ << " Hz\n";

  ss << "***************************************************************"
        "**********************************************************************"
        "*"
     << "\n";

  return ss;
}

/**
 * @brief Ideal measurement model for MAG measurements.
 *
 * This function calculates the ideal measurement model for MAG measurements.
 * The ideal measurement model is the magnetic field vector in the sensor frame
 * without any errors, distortion, or noise.
 *
 * @param[in] q_b_n_true The true attitude quaternion of the body frame with
 * respect to the navigation frame.
 *
 * @return The ideal measurement vector in the sensor frame.
 */
Eigen::Vector3d MagSimulator::calcIdealMeasurement(
    const Eigen::Quaterniond q_b_n_true) {
  // Get rotation matrices for frame transformations
  Eigen::Matrix<double, 3, 3> C_n_b = q_b_n_true.toRotationMatrix().transpose();
  Eigen::Matrix<double, 3, 3> C_b_s = magSimParams_.sensorRotation;

  // Calculate true magnetic field vector in sensor frame
  Eigen::Vector3d m_s_meas = C_b_s * C_n_b * localMagFieldVector_;

  return m_s_meas;
}

/**
 * @brief Hard iron bias model for MAG measurements.
 *
 * This function adds the hard iron bias to the measurement vector.
 *
 * @param[in] measurement Vector of MAG measurements.
 *
 * @return Measurement vector with added hard iron bias.
 */
Eigen::Vector3d MagSimulator::calcHardIronBiasModel(
    const Eigen::Vector3d& measurement) {
  // Add hard iron bias to measurement
  Eigen::Vector3d measurementWithHardIronBias =
      measurement + magSimParams_.hardIronBias;

  return measurementWithHardIronBias;
}

/**
 * @brief Soft iron distortion model for MAG measurements.
 *
 * This function applies the soft iron distortion to the measurement vector.
 *
 * @param[in] measurement Vector of MAG measurements.
 *
 * @return Measurement vector with applied soft iron distortion.
 */
Eigen::Vector3d MagSimulator::calcSoftIronDistortionModel(
    const Eigen::Vector3d& measurement) {
  // Apply soft iron distortion
  Eigen::Vector3d measurementWithSoftIronDistortion =
      magSimParams_.softIronDistortion * measurement;

  return measurementWithSoftIronDistortion;
}

/**
 * @brief Stochastic error model for MAG measurements.
 *
 * This function adds stochastic errors to the measurement vector.
 * The function uses a Gauss-Markov discrete-time equivalent state-space
 * model. Axis-specific colored noise is generated for each axis. The
 * colored noise is then added to the measurement vector. The state-space
 * model is updated using the updateDiscreteTimeEquivalentStateSpaceModel
 * function.
 *
 * @param[in] measurement Vector of MAG measurements.
 *
 * @return Measurement vector with added stochastic errors.
 */
Eigen::Vector3d MagSimulator::calcStochasticErrorModel(
    const Eigen::Vector3d& measurement) {
  // Vector of measurement with stochastic error
  Eigen::Vector3d measurementWithStochasticError;

  // Vector of colored noise for each axis
  Eigen::Vector3d coloredNoise;

  // Update discrete-time equivalent state-space model for each axis
  coloredNoise(0) = updateDiscreteTimeEquivalentStateSpaceModel(
      pStochasticErrors_, magSimParams_.N(axisX), magSimParams_.B(axisX),
      magSimParams_.K(axisX), magSimParams_.corrTime(axisX), axisX);
  coloredNoise(1) = updateDiscreteTimeEquivalentStateSpaceModel(
      pStochasticErrors_, magSimParams_.N(axisY), magSimParams_.B(axisY),
      magSimParams_.K(axisY), magSimParams_.corrTime(axisY), axisY);
  coloredNoise(2) = updateDiscreteTimeEquivalentStateSpaceModel(
      pStochasticErrors_, magSimParams_.N(axisZ), magSimParams_.B(axisZ),
      magSimParams_.K(axisZ), magSimParams_.corrTime(axisZ), axisZ);

  // Add stochastic error to measurement
  measurementWithStochasticError = measurement + coloredNoise;

  return measurementWithStochasticError;
}

/**
 * @brief Update the discrete-time equivalent state-space model for stochastic
 *        errors.
 *
 * This function updates the discrete-time equivalent state-space model for
 * stochastic errors. The function uses a Gauss-Markov discrete-time equivalent
 * state-space model to generate colored noise for an axis. The colored noise is
 * output as a double (scalar).
 *
 * @param[in] pStochasticErrors Pointer to the stochastic errors struct.
 * @param[in] N The PSD of "velocity" random walk.
 * @param[in] B The PSD of bias instability.
 * @param[in] K The PSD of "acceleration" random walk.
 * @param[in] corrTime The Gauss-Markov time correlation constant.
 * @param[in] axisId The axis identifier (X, Y, or Z).
 *
 * @return The colored noise as a double (scalar).
 */
double MagSimulator::updateDiscreteTimeEquivalentStateSpaceModel(
    std::shared_ptr<StochasticErrors> pStochasticErrors, const double N,
    const double B, const double K, const double corrTime,
    const AxisIdentifier axisId) {
  // PSD "velocity" random walk
  double S_N = N * N;

  // PSD bias instability
  double S_B = (2 * B * B * std::log(2)) / (M_PI * 0.4365 * 0.4365 * corrTime);

  // PSD "acceleration" random walk
  double S_K = K * K;

  // Gauss-Markov time correlation constant
  double corrConstant = 1 / corrTime;

  // Discrete-time state-space model matrices
  Eigen::Matrix2d Phi_k;
  Phi_k << std::exp(-corrConstant * dt_), 0, 0, 1;

  Eigen::MatrixXd H(1, 2);
  H << 1, 1;

  // Discrete-time bias instability covariance
  double Q_B_k =
      S_B / (2 * corrConstant) * (1 - std::exp(-2 * corrConstant * dt_));

  // Discrete-time "acceleration" random walk covariance
  double Q_K_k = S_K * dt_;

  // Discrete-time measurement noise covariance ("velocity" random walk)
  double Q_N_k = S_N / dt_;

  // Define random number vector
  Eigen::Vector3d randomNumbers;

  if (useFixedRandomNumbers_ == true) {
    // Draw fixed random numbers for testing/debugging
    randomNumbers = Eigen::Vector3d(1.0, 2.0, 3.0);
  } else {
    // Draw normal distributed random samples from white noise processes
    randomNumbers =
        Eigen::Vector3d(drawRandNormalDistNum(), drawRandNormalDistNum(),
                        drawRandNormalDistNum());
  }

  // Draw measurement noise scalar ("velocity" random walk)
  Eigen::VectorXd nu_N_k =
      Eigen::VectorXd::Constant(1, std::sqrt(Q_N_k) * randomNumbers(0));

  // Draw process noise vector (bias instability and "acceleration" random walk)
  Eigen::Vector2d w_BK_k = Eigen::Vector2d(std::sqrt(Q_B_k) * randomNumbers(1),
                                           std::sqrt(Q_K_k) * randomNumbers(2));

  // Create state vector for one axis
  double z_B = pStochasticErrors->z_B(axisId);
  double z_K = pStochasticErrors->z_K(axisId);

  Eigen::Vector2d x_k = Eigen::Vector2d(z_B, z_K);

  // Calculate new state vector
  Eigen::Vector2d x_k_1 = Phi_k * x_k + w_BK_k;

  // Calculate new measurement vector
  Eigen::VectorXd z_k = H * x_k + nu_N_k;

  // Update internal Gauss-Markov state space model
  pStochasticErrors->z_N(axisId) = z_k(0);
  pStochasticErrors->z_B(axisId) = x_k_1(0);
  pStochasticErrors->z_K(axisId) = x_k_1(1);

  // Return colored noise as double (scalar)
  return z_k(0);
}

/**
 * @brief Saturation model for MAG measurements.
 *
 * This function saturates the measurement vector to the absolute values of
 * the measRange vector. This replicates that an MAG can only measure values
 * within a certain range.
 *
 * @param[in] measurement Vector of MAG measurements.
 *
 * @return Saturated measurement vector.
 */
Eigen::Vector3d MagSimulator::calcSaturationModel(
    const Eigen::Vector3d& measurement) {
  // Saturated measurement vector
  Eigen::Vector3d saturatedMeasurement;

  // Saturate elements of measurement to absolute values of measRange
  saturatedMeasurement(0) =
      std::min(std::abs(measurement(0)), magSimParams_.measRange(0)) *
      (measurement(0) >= 0 ? 1 : -1);
  saturatedMeasurement(1) =
      std::min(std::abs(measurement(1)), magSimParams_.measRange(1)) *
      (measurement(1) >= 0 ? 1 : -1);
  saturatedMeasurement(2) =
      std::min(std::abs(measurement(2)), magSimParams_.measRange(2)) *
      (measurement(2) >= 0 ? 1 : -1);

  return saturatedMeasurement;
}

/**
 * @brief Quantization model for MAG measurements.
 *
 * This function quantizes the measurement vector to the resolution of the
 * resolution vector. This replicates that an MAG can only measure values with
 * a certain resolution (analog/digital conversion).
 *
 * @param[in] measurement Vector of MAG measurements.
 *
 * @return Quantized measurement vector.
 */
Eigen::Vector3d MagSimulator::calcQuantizationModel(
    const Eigen::Vector3d& measurement) {
  // Quantized measurement vector
  Eigen::Vector3d quantizedMeasurement;

  // Quantize elements of measurement to resolution
  quantizedMeasurement(0) =
      std::round(measurement(0) / magSimParams_.resolution(0)) *
      magSimParams_.resolution(0);
  quantizedMeasurement(1) =
      std::round(measurement(1) / magSimParams_.resolution(1)) *
      magSimParams_.resolution(1);
  quantizedMeasurement(2) =
      std::round(measurement(2) / magSimParams_.resolution(2)) *
      magSimParams_.resolution(2);

  return quantizedMeasurement;
}

/**
 * @brief Draws a random number from a normal distribution.
 *
 * This function draws a random number from a normal distribution with the given
 * mean and standard deviation.
 *
 * @return Single random number from the normal distribution.
 */
double MagSimulator::drawRandNormalDistNum() {
  // Generate normal distributed random number
  return normalDistribution_(randomNumberGenerator_);
}

}  // namespace mag_simulator
